**提示4-1**：C语言中的数学函数可以定义成“返回类型 函数名(参数列表) { 函数体 }”，其中函数体的最后一条语句应该是“return 表达式；”。定义函数返回类型为void，并且无须使用return（除非希望在函数运行中退出函数）。

**提示4-3**：如果在执行函数的过程中碰到了return语句，将直接退出这个函数，不去执行后面的语句。相反，如果在执行过程中始终没有return语句，则会**返回一个不确定的值**。幸好，-Wall可以捕捉到这一可疑情况并产生警告。

**提示4-4**：在算法竞赛中，请总是让main函数返回0。

**提示4-5**：在C语言中，定义结构体的方法为“struct 结构体名称{ 域定义 };”，注意花括号的后面还有一个分号。

**提示4-6**：为了使用方便，往往用“typedef struct { 域定义; }类型名;”的方式定义一个新类型名。这样，就可以像原生数据类型一样使用这个自定义类型。

计算组合数。编写函数，参数是两个非负整数n和m，返回组合数$$\frac{n!}{m!+(n-m)!}$$其中m<=n<=25.

既然题目中的公式多次出现n!，将其作为一个函数编写是比较合理的：

程序4-1 组合数（**有问题**）

```c
long long factorial(int n){
long long m = 1;
for(int i = 1; i <= n; i++)
m *= i;
return m;
}
long long C(int n, int m)
{
return factorial(n)/(factorial(m)*factorial(n-m)));
}
//n=21，m=1的返回值竟然是-1
```

**提示4-7**：即使最终答案在所选择的数据类型范围之内，计算的中间结果仍然可能溢出。

如何避免中间结果溢出？溢出的是阶乘的部分,办法是进行“约分”。

一个简单的方法是利用n!/m!=(m+1)(m+2)…(n-1)n

一时间没有看明白，数学是真的还给老师了，得研究明白才是

$$\frac{n!}{m!+(n-m)!}$$展开之后

$$\frac{n*(n-1)*(n-2)...2*1}{m*(m-1)*(m-2)*(m-3)...3*2*1*(n-m)*(n-m-1)*...*2*1}$$

因为n>=m，所以m在1~n之间，这样可以把n!除以m!约分得n*(n-1)一直到(m+1)

$$\frac{n *(n-1) *(n-2)……(m+2) *(m+1)}{(n-m) *(n-m-1) *(n-m-2)…… *3 *2 *1}$$

那为什么当m<n-m时要把m变成n-m？

m<n-m则m<n/2，设M=n-m>n/2

从小到大：（为了不把变换后的m与变换前的m弄混，把变化后的m记为M=n-m）

0 1 2 3 ……m……n/2……M……(n-1) n

因为组合数的公式，分子是大于分母的，所以分子的乘积比较大，容易溢出，要想优化，就得让分子乘积变小。

M=n-m带入组合式公式之后就是：

$$\frac{n!}{M!(n-M)!=(n-m)!(n-(n-m))!=(n-m)!m!}$$

所以式子并没有变化，同样可以进行约分

$$\frac{n *(n-1) *(n-2)……(M+2) *(M+1)}{(n-M) *(n-M-1) *(n-M-2)…… *3 *2 *1}$$

0 1 2 3 ……m ……n/2……M ……(n-1) n

**由于M是大于m的，所以分子的乘积缩小，溢出问题得到缓解**，有意思

程序4-2 组合数

```c
long long C(int n, int m) {
if(m < n-m) m = n-m;	//当m<n-m时把m变成n-m 
long long ans = 1;
for(int i = m+1; i <= n; i++) ans *= i;
for(int i = 1; i <= n-m; i++) ans /= i;
return ans;
}
```

**提示4-8**：对复杂的表达式进行化简有时不仅能减少计算量，还能减少甚至避免中间结果溢出。

素数判定。编写函数，参数是一个正整数n，如果它是素数，返回1，否则返回0。

判断一个事物是否具有某一性质的函数还有一个学术名称——谓词（predicate）

程序4-3 素数判定（有问题）

```c
//n=1或者n太大时请勿调用
int is_prime(int n)
{
for(int i = 2; i*i <= n; i++)//只判断不超过sqrt(x)的整数i
if(n % i == 0) return 0;	//及时退出
    return 1;
}

```

提示4-9：建议把谓词（用来判断某事物是否具有某种特性的函数）命名成“is_xxx”的形式，返回int值，非0表示真，0表示假。



n太小时不难解释：n=1会被错误地判断为素数（因为确实没有其他因子）。n太大时的理由：i * i可能会溢出！如果n是一个接近int的最大值的素数，则当循环到i=46340时，i * i=2147395600<n；但i=46341时，i * i = 2147488281，超过了int的最大值，溢出变成负数，仍然满足i*i<n。若n不是太大，可能出现101128442溢出后等于2147483280，终止循环；但如果n= 2147483647，循环将一直进行下去。

**提示4-10**：编写函数时，应尽量保证该函数能对任何合法参数得到正确的结果。如若不然，应在显著位置标明函数的缺陷，以避免误用。

程序4-4 素数判定（2）

```c
int is_prime(int n)
{
if(n <= 1) return 0;
int m = floor(sqrt(n) + 0.5);
for(int i = 2; i <= m; i++)
if(n % i == 0) return 0;
return 1;
}
```

除了特判n≤1的情况外，程序中还使用了变量m，一方面避免了每次重复计算sqrt(n)，另一方面也通过四舍五入避免了浮点误差



## 4.2 函数调用与参数传递

**提示4-11**：函数的形参和在函数内声明的变量都是该函数的局部变量。无法访问其他函数的局部变量。局部变量的存储空间是临时分配的，函数执行完毕时，局部变量的空间将被释放，其中的值无法保留到下次使用。在函数外声明的变量是全局变量，可以被任何函数使用。操作全局变量有风险，应谨慎使用。

### 4.2.2 调用栈

调用栈描述的是函数之间的调用关系。它由多个栈帧（Stack Frame）组成，每个栈帧对应着一个未运行完的函数。栈帧中保存了该函数的返回地址和局部变量，因而不仅能在执行完毕后找到正确的返回地址，还很自然地保证了不同函数间的局部变量互不相干——因为不同函数对应着不同的栈帧。

提示4-12：C语言用调用栈（Call Stack）来描述函数之间的调用关系。调用栈由栈帧（Stack Frame）组成，每个栈帧对应着一个未运行完的函数。在gdb中可以用backtrace（简称bt）命令打印所有栈帧信息。若要用p命令打印一个非当前栈帧的局部变量，可以用frame命令选择另一个栈帧。



第1步：编译程序。
gcc swap.c -std=c99 -g生成可执行程序a.exe（在Linux下是a.out）。编译选项-g告诉编译器生成调试信息。编译
选项-std=c99告诉编译器按照C99标准编译代码。

第2步：运行gdb。

gdb a.out
这样，gdb在运行时会自动装入刚才生成的可执行程序。

第3步：查看源码。

第4步：加断点并运行。

第5步：查看调用栈。

这里(gdb)是gdb的提示符，字母l是输入的命令，为list（列出程序清单）的缩写。

其中，b命令把断点设在了第4行，r命令运行程序，之后碰到了断点并停止。

根据bt命令，调用栈中包含两个栈帧：#0 和#1，其中0号是当前栈 帧——swap函数，1号是其“上一个”栈帧——main函数。这里甚至能看到swap函数的返回地址

使用p命令可以打印变量值。首先查看当前栈帧中a和b的值，分别等于4和3——这正是用三变量法交换后的结果。接下来用up命令选择上一个栈帧，再次使用p命令查看a和b的值，这次却得到3和4，为main函数中的a和b。前面讲过，在函数调用时，a、b只起到了“计算实参”的作用。但实参被赋值到形参之后，main函数中的a和b也完成了它们的使命。swap函数甚至无法知道main函数中也有着和形参同名的a和b变量，当然也就无法对其进行修改。
最后要用q命令退出gdb。

![image-20210128170719514](C:\Users\55018\AppData\Roaming\Typora\typora-user-images\image-20210128170719514.png)

### 4.2.3 用指针作参数

程序4-6 用函数交换变量（正确）

```c
#include<stdio.h>
void swap(int* a, int* b)
{
int t = *a; *a = *b; *b = t;
}
int main()
{
int a = 3, b = 4;
swap(&a, &b);
printf("%d %d\n", a, b);
return 0;
}

```

变量名前面加“&”得到的是该变量的地址。

**提示4-13**：C语言的变量都是放在内存中的，而内存中的每个字节都有一个称为地址（address）的编号。每个变量都占有一定数目的字节（可用sizeof运算符获得），其中第一个字节的地址称为变量的地址。

下面用gdb来调试上面的程序

```
(gdb) bt
#0 swap (a=0x22ff74, b=0x22ff70) at swap2.c:4
#1 0x0040135c in main() at swap2.c:8
(gdb) p a
$1 = (int *) 0x22ff74
(gdb) p b
$2 = (int *) 0x22ff70
(gdb) p *a
$3 = 4
(gdb) p *b
$4 = 3
(gdb) up
#1 0x0040135c in main() at swap2.c:8
8 swap(&a, &b);
(gdb) p a
$5 = 4
(gdb) p b
$6 = 3
(gdb) p &a
$7 = (int *) 0x22ff74
(gdb) p &b
$8 = (int *) 0x22ff70
```

数值0x22ff74和0x22ff70是两个地址（以0x开头的整数以十六进制表示),而前面的(int *)表明a和b是指向int类型的指针。

**提示4-14**：用int* a声明的变量a是指向int型变量的指针。赋值a = &b的含义是把变量b的地址存放在指针a中，表达式*a代表a指向的变量，既可以放在赋值符号的左边（左值），也可以放在右边（右值）。

`(*a)++`。注意不要写成`*a++`，因为“++”运算符的优先级高于“取内容”运算符“ * ”  ，实际上会被解释成*(a++)。

**提示4-15：千万不要滥用指针，这不仅会把自己搞糊涂，还会让程序产生各种奇怪的错误。事实上，本书的程序会很少使用指针。**



### 4.2.5 数组作为参数和返回值

程序4-7 计算数组的元素和（错误）

```c
int sum(int a[]) {
int ans = 0;
for(int i = 0; i < sizeof(a); i++)
    ans += a[i];
return ans;
}

```



**因为把数组作为参数传递给函数时，实际上只有数组的首地址作为指针传递给了函数**。换句话说，在函数
定义中的int a[]等价于int *a。在只有地址信息的情况下，是无法知道数组里有多少个元素的。

程序4-8 计算数组的元素和（正确）

```c
int sum(int* a, int n) {
int ans = 0;
for(int i = 0; i < n; i++)
ans += a[i];
return ans;
}
```

直接把参数a写成了int* a，暗示a实际上是一个地址。在函数调用时a不一定非要传递一个数组

**提示4-16**：以数组为参数调用函数时，实际上只有数组首地址传递给了函数，需要另加一个参数表示元素个数。除了把数组首地址本身作为实参外，还可以利用指针加减法把其他元素的首地址传递给函数。

```c
int main() {
int a[] = {1, 2, 3, 4};
printf("%d\n", sum(a+1, 3));
return 0;
}
```



指针a+1指向a[1]，即2这个元素（数组元素从0开始编号）。因此函数sum“看到”{2, 3, 4}这个数组，因此返回9。
一般地，若p是指针，k是正整数，则p+k就是指针p后面第k个元素，p-k是p前面的第k个元素，而如果p1和p2是类型相同的指针，则p2-p1是从p1到p2的元素个数（不含p2）。下面是sum函数的另外两种写法。

程序4-9 计算左闭右开区间内的元素和（两种写法）

```c
//写法一：
int sum(int* begin, int* end) {
int n = end - begin;
int ans = 0;
for(int i = 0; i < n; i++)
ans += begin[i];
return ans;
}
//写法二：
int sum(int* begin, int* end) {
int *p = begin;
int ans = 0;
for(int *p = begin; p != end; p++)
ans += *p;
return ans;
}

```

### 4.2.6 把函数作为函数的参数

把函数作为函数的参数？看上去挺奇怪的，但实际上有一个非常典型的应用——排序。

**例题4-1 古老的密码（Ancient Cipher, NEERC 2004, UVa1339）**

给定两个长度相同且不超过100的字符串，判断是否能把其中一个字符串的各个字母重排，然后对26个字母做一个一一映射，使得两个字符串相同。例如，JWPUDJSTVP重排后可以得到WJDUPSJPVT，然后把每个字母映射到它前一个字母（B->A, C->B, …, Z->Y, A->Z），得到VICTORIOUS。输入两个字符串，输出YES或者NO。

【分析】
既然字母可以重排，则每个字母的位置并不重要，重要的是每个字母出现的次数。这样可以先统计出两个字符串中各个字母出现的次数，得到两个数组cnt1[26]和cnt2[26]。下一步需要一点想象力：只要两个数组排序之后的结果相同，输入的两个串就可以通过重排和一一映射变得相同。这样，问题的核心就是排序。

C语言的stdlib.h中有一个叫qsort的库函数，实现了著名的快速排序算法。它的声明是这样的：

```c
void qsort ( void * base, size_t num, size_t size, 
            int ( * comparator ) ( const void *, const void *) );
```

前3个参数不难理解，分别是待排序的数组起始地址、元素个数和每个元素的大小。最后一个参数比较特别，是一个指向函数的指针，该函数应当具有这样的形式：

`int cmp(const void *, const void *) { … }`

这里的新内容是指向常数的“万能”的指针：const void *，它可以通过强制类型转化变成任意类型的指针。

```c
int cmp ( const void *a , const void *b ) {
return *(int *)a - *(int *)b;
}
```

但在算法竞赛中一般不使用它，而是使用C++中的sort函数



## 4.3 递归

**递归的定义如下：**
**递归：**
**参见“递归”**

**提示4-17**：C语言支持递归，即函数可以直接或间接地调用自己。但要注意为递归函数编写终止条件，否则将产生无限递归。

### 4.3.3 C语言对递归的支持

程序4-10 用递归法计算阶乘

```c
#include<stdio.h>
int f(int n)
{
return n == 0 ? 1 : f(n-1)*n;
}
int main()
{
printf("%d\n", f(3));
return 0;
}

```



下面再次借助gdb来调试阶乘这段程序。
首先用b f命令设置断点——除了可以按行号设置外，也可以直接给出函数名，断点将设置在函数的开头。下面用r命令运行程序，并在断点处停下来。接下来用**s命令单步执行**：

```
(gdb) r
Starting program: C:\a.exe
Breakpoint 1, f (n=3) at factorial.c:3
3 return n == 0 ? 1 : f(n-1)*n;
(gdb) s
Breakpoint 1, f (n=2) at factorial.c:3
3 return n == 0 ? 1 : f(n-1)*n;
(gdb) s
Breakpoint 1, f (n=1) at factorial.c:3
3 return n == 0 ? 1 : f(n-1)*n;
(gdb) s
Breakpoint 1, f (n=0) at factorial.c:3
3 return n == 0 ? 1 : f(n-1)*n;
(gdb) s
4 }
```

看到了吗？在第一次断点处，n=3（3是main函数中的调用参数），接下来将调用f(3-1)，即f(2)，因此单步一次后显示n=2。由于n==0仍然不成立，继续递归调用，直到n=0。这时不再递归调用了，执行一次s命令以后会到达函数的结束位置。

好好看看下面的调用栈

```
(gdb) bt
#0 f (n=0) at factorial.c:4
#1 0x00401308 in f (n=1) at factorial.c:3
#2 0x00401308 in f (n=2) at factorial.c:3
#3 0x00401308 in f (n=3) at factorial.c:3
#4 0x00401359 in main () at factorial.c:6
(gdb) s
4 }
(gdb) bt
#0 f (n=1) at factorial.c:4
#1 0x00401308 in f (n=2) at factorial.c:3
#2 0x00401308 in f (n=3) at factorial.c:3
#3 0x00401359 in main () at factorial.c:6
(gdb) s
4 }
(gdb) bt
#0 f (n=2) at factorial.c:4
#1 0x00401308 in f (n=3) at factorial.c:3
#2 0x00401359 in main() at factorial.c:6
(gdb) s
4 }
(gdb) bt
#0 f (n=3) at factorial.c:4
#1 0x00401359 in main() at factorial.c:6
(gdb) s
6
main() at factorial.c:7
7 return 0;
(gdb) bt
#0 main() at factorial.c:7

```

每次执行完s指令，都会有一层递归调用终止，直到返回main函数。事实上，如果在递归调用初期查看调用栈，则会发现每次递归调用都会多一个栈帧——和普通的函数调用并没有什么不同。确实如此。由于使用了调用栈，C语言自然支持了递归。在C语言的函数中，调用自己和调用其他函数并没有任何本质区别，都是建立新栈帧，传递参数并修改当前代码行。在函数体执行完毕后删除栈帧，处理返回值并修改当前代码行。



### 4.3.4 段错误与栈溢出

把main函数的f(3)换成f(100000000)试试 -------->没有输出

用-g编译后用gdb载入，二话不说就用r执行。

```c
(gdb) r
Starting program: C:\a.exe
Program received signal SIGSEGV, Segmentation fault.
0x00401303 in f (n=99869708) at 4-6.c:3
3 return n == 0 ? 1 : f(n-1)*n;
```

gdb中显示程序收到了SIGSEGV信号——段错误。

编译后产生的可执行文件里都保存着些什么内容？答案是和操作系统相关。例如，UNIX/Linux用的ELF格式，DOS下用的是COFF格式，而Windows用的是PE文件格式（由COFF扩充而来）。这些格式不尽相同，但都有一个共同的概念——段。

“段”（segmentation）是指二进制文件内的区域，所有某种特定类型信息被保存在里面。

可以用size程序得到可执行文件中各个段的大小。

```
D:\>size a.exe
text data bss dec hex filename
2756 740 224 3720 e88 a.exe
```

**提示4-19**：在可执行文件中，正文段（Text Segment）用于储存指令，数据段（Data Segment）用于储存已初始化的全局变量，BSS段（BSS Segment）用于储存未赋值的全局变量所需的空间。

调用栈在哪里？它并不储存在可执行文件中，而是在运行时创建。调用栈所在的段称为堆栈段（Stack Segment）。和其他段一样，堆栈段也有自己的大小，不能被越界访问，否则就会出现段错误（Segmentation Fault）。

每次递归调用都需要往调用栈里增加一个栈帧，久而久之就越界了。这种情况叫做栈溢出（Stack Overflow）。

**提示4-20**：在运行时，程序会动态创建一个堆栈段，里面存放着调用栈，因此保存着函数的调用关系和局部变量。

学完汇编再回头看，知识真的就是串联起来的，真心是非常有意思的。

那么栈空间究竟有多大呢？这和操作系统相关。在Linux中，栈大小是由系统命令ulimit指定的，例如，ulimit -a显示当前栈大小，而ulimit -s 32768将把栈大小指定为32MB。但在Windows中，栈大小是储存在可执行文件中的。使用gcc可以这样指定可执行文件的栈大小：gcc -Wl,--stack=16777216，这样栈大小就变为16MB。

建议“把较大的数组放在main函数外”。别忘了，局部变量也是放在堆栈段的。栈溢出不一定是递归调用太多，也可能是局部变量太大。只要总大小超过了允许的范围，就会产生栈溢出。



## 4.4 竞赛题目选讲

**例题4-2** 刽子手游戏（Hangman Judge, UVa 489）

**<img src="C:\Users\55018\AppData\Roaming\Typora\typora-user-images\image-20210201200534498.png" alt="image-20210201200534498" style="zoom: 50%;" />**

刽子手游戏其实是一款猜单词游戏，如图所示。游戏规则是这样的：计算机想一个单词让你猜，你每次可以猜一个字母。如果单词里有那个字母，所有该字母会显示出来；如果没有那个字母，则计算机会在一幅“刽子手”画上填一
笔。这幅画一共需要7笔就能完成，因此你最多只能错6次。注意，猜一个已经猜过的字母也算错。

在本题中，你的任务是编写一个“裁判”程序，输入单词和玩家的猜测，判断玩家赢了（You win.）、输了（You lose.）还是放弃了（You chickened out.）。每组数据包含3行，第1行是游戏编号（-1为输入结束标记），第2行是计算机想的单词，第3行是玩家的猜测。后两行保证只含小写字母。

样例输入：
1
cheese
chese
2

cheese
abcdefg
3
cheese
abcdefgij
-1
样例输出:
Round 1
You win.
Round 2
You chickened out.
Round 3
You lose.



一般而言，程序不是直接从第一行开始写到最后一行结束，而是遵循两种常见的顺序之一：自顶向下和自底向上。什么叫自顶向下呢？简单地说，就是**先写框架，再写细节**。实际上，之前已经用过这个方法了，就是先写“伪代码”，然后转化成实际的代码。有了“函数”这个工具之后，可以更好地贯彻这个方法：先写主程序，包括对函数的调用，再实现函数本身。自底向上和这个顺序相反，是先写函数，再写主程序。对于编写复杂软件来说，自底向
下的构建方式有它独特的优势。但在算法竞赛中，这样做的选手并不多见。

**程序4-11** 刽子手游戏——程序框架

```c
#include<stdio.h>
#include<string.h>
#define maxn 100
int left,chance;	//还需要猜left个位置,错chance次之后就会输
char s[maxn],s2[maxn];//答案是字符串s,玩家猜的字母序列是s2
int win,lose;//win=1表示已经赢了;lose=1表示已经输了

void guess(char ch) { … }

int main(){
    int rnd;
    while(scanf("%d%s%s",&rnd,s,s2)==3&&rnd!=-1){
        printf("Round %d\n",rnd);
        win=lose=0;//求解一组新数据之前要初始化
        left=strlen(s);
        chance=7;
        for(int i=0;i<strlen(s2);i++){
			guess(s2[i]);	//猜
            if(win||lose) break;//检查状态
        }
        //根据结果进行输出
        if(win) printf("You win.\n");
        else if(lose) printf("You lose.\n");
        else printf("You chickend out.\n");
    }
    return 0;
}
```

下一步是实现guess函数。在编写这个函数时，可能会注意到一个问题：题目中说了猜过的字母再猜一次算错，可是似乎并没有保存哪些字母已经猜过。一个解决方案是在程序框架中增加一个字符数组int guessed[256]，让guessed[ch]标识字母ch是否已经猜过。但其实还有一个更简单的方法，就是将猜对的字符改成空格，像这样：

```c
void guess(char ch) {
int bad = 1;
for(int i = 0; i < strlen(s); i++)
	if(s[i] == ch) { left--; s[i] = ' '; bad = 0; }
if(bad) --chance;
if(!chance) lose = 1;
if(!left) win = 1;
}
```

一般来说，减少变量的个数对于编程和调试都会有帮助。



**例题4-3** 救济金发放（The Dole Queue, UVa 133）

​	n(n<20)个人站成一圈，**逆时针编号为1～n**。有两个官员，A从1开始逆时针数，B从n开始顺时针数。在每一轮中，官员A数k个就停下来，官员B数m个就停下来（注意有可能两个官员停在同一个人上）。接下来被官员选中的人（1个或者2个）离开队伍。

​	输入n，k，m 输出每轮里被选中的人的编号（如果有两个人，先输出被A选中的）。例如，n=10，k=4，m=3，输出为4 8, 9 5, 3 1, 2 6, 10, 7。注意：输出的每个数应当恰好占3列。



解：用一个大小为0的数组表示人站成的圈。为了避免人走之后移动数组元素，用0表示离开队伍的人，数数时跳过即可。主程序如下：

```c
#include<stdio.h>
#define maxn 25
int n,k,m,a[maxn];
//逆时针走t步，步长为d（-1表示顺时针走），返回新位置
int go(int p,int d,int t){...}

int main(){
    while(scanf("%d%d%d",&n,&k,&m)==3&&n){
        for(int i=1;i<=n;i++) a[i]=i;
        int left=n;//剩下的人数
        int p1=n,p2=1;
        while(left){
            p1=go(p1,1,k);
            p2=go(p2,-1,m);
            printf("%3d",p1);
            left--;
            if(p2!=p1){printf("%3d",p2); left--;}
            a[p1] = a[p2] = 0;
            if(left) printf(",");
            
        }
        printf("\n");
            
    }
    return 0;
}
```

注意go这个函数。当然也可以写两个函数：逆时针go和顺时针go，但是仔细思考后发现这两个函数可以合并：逆时针和顺时针数数的唯一区别只是下标是加1还是减1。把这个+1/-1抽象为“步长”参数，就可以把两个go统一了。代码如下：

```c
int go(int p, int d, int t) {
while(t--) {
	do { p = (p+d+n-1) % n + 1; } //是零的时候如果d=1，相当于p+1，d=-1，相当于p-1.跳过0
    while(a[p] == 0); //走到下一个非0数字
}
return p;//得到值（1-20）。代码有些巧妙
}
```



==此题还未搞清楚，需要花费额外时间==

**例题4-4** 信息解码（Message Decoding, ACM/ICPC World Finals 1991, UVa 213）

考虑下面的01串序列：
0, 00, 01, 10, 000, 001, 010, 011, 100, 101, 110, 0000, 0001, …, 1101, 1110, 00000, …
首先是长度为1的串，然后是长度为2的串，依此类推。如果看成二进制，相同长度的后一个串等于前一个串加1。注意上述序列中不存在全为1的串。

你的任务是编写一个解码程序。首先输入一个编码头（例如AB#TANCnrtXc），则上述序列的每个串依次对应编码头的每个字符。例如，0对应A，00对应B，01对应#，…，110对应X，0000对应c。接下来是编码文本（可能由多行组成，你应当把它们拼成一个长长的01串）。编码文本由多个小节组成，**每个小节的前3个数字代表小节中每个编码的长度**（用二进制表示，例如010代表长度为2），然后是各个字符的编码，以全1结束（例如，编码长度
为2的小节以11结束）。编码文本以编码长度为000的小节结束。

例如，编码头为`$#**\，编码文本为0100000101101100011100101000，应这样解码：010(编码长度为2)00(#)00(#)10(*)11(小节结束)011(编码长度为3)000(\)111(小节结束)001(编码长度为1)0($)1(小节结束)000(编码结束)`。

只需把编码理解成二进制，用(len, value)这个二元组来表示一个编码，其中len是编码长度，value是编码对应的十进制值。如果用`codes[len][value]`保存这个编码所对应的字符，则主程序看上去应该是这个样子的。

```c
#include<stdio.h>
#include<string.h>
int readchar(){...}
int readint(int c){...}

int code[8][1<<8];//1<<8=256
int readcodes(){...}

int main(){
    while(readcodes()){
        //无法读取更多编码头时退出
		//printcodes();
		for(;;){
            int len=readint(3);
            if(len==0) break;
            //printf("len=%d\n", len)
            for(;;){
                int v=readint(len);
                //printf("v=%d\n", v);
                if(v==(1<<len)-1) break;
                putchar(code[len][v]);
            }
                
        }
        putchar('\n');
    }
    return 0;
}
```

主程序里接连使用了两个还没有介绍的函数：readcodes和readint。前者用来读取编码，后者读取c位二进制字符（即0和1），并转化为十进制整数。



**本题的调试方法也很有代表性。上面的代码中已经包含了几条注释掉的printf语句，用于打印出一些关键变量的值。如果程序的输出不是想要的结果，题目中的举例就派上用场了：只需把举例中的解释和程序输出的中间结果一一对照，就能知道问题出在哪里。**

有一说一，确实

编写readint时会遇到同一个问题：如何处理“编码文本可以由多行组成”这个问题？方法有很多种，笔者的方案是再编写一个“跨行读字符”的函数readchar。

```c
int readchar() {
	for(;;) {
		int ch = getchar();
		if(ch != '\n' && ch != '\r') return ch; //一直读到非换行符为止
	}
}
int readint(int c) {
	int v = 0;
	while(c--) v = v * 2 + readchar() - '0';
	return v;
}

```

下面是函数readcodes。**首先使用memset清空数组**（这是个好习惯。还记得之前讲过的多数据题目的常见错误吗？），编码头自身占一行，所以应该用readchar读取第一个字符，而用普通的getchar读取剩下的字符，直到\n。这样做，代码比较简单，但有些读者可能会觉得有些别扭。没关系，你完全可以使用另外一套自己觉得更清晰的方法。

```c
int readcodes() {
	memset(code, 0, sizeof(code)); //清空数组
	code[1][0] = readchar(); //直接调到下一行开始读取。如果输入已经结束，会读到EOF
	for(int len = 2; len <= 7; len++) {
		for(int i = 0; i < (1<<len)-1; i++) {
			int ch = getchar();
			if(ch == EOF) return 0;
			if(ch == '\n' || ch == '\r') return 1;
			code[len][i] = ch;
		}
	}
	return 1;
}
```

最后是前面提到的printcodes函数。这个函数对于解题来说不是必需的，但对于调试却是有用的。

```c
void printcodes() {
for(int len = 1; len <= 7; len++)
for(int i = 0; i < (1<<len)-1; i++) {
if(code[len][i] == 0) return;
printf("code[%d][%d] = %c\n", len, i, code[len][i]);
}
}

```

由于每次读取编码头时把codes数组清空了，所以只要遇到字符为0的情况，就表示编码
头已经结束。



## 4.5 注解与习题

### 4.5.1 头文件、副作用及其他

表4-1 常用函数及头文件

![image-20210201211340395](C:\Users\55018\AppData\Roaming\Typora\typora-user-images\image-20210201211340395.png)

C语言的函数可以有副作用（全局变量，静态变量等影响），而不像数学函数那样“纯”。



最后一个话题是关于浮点误差的。例如：

```c
#include<stdio.h>
int main() {
double f;
for(f = 2; f > 1; f -= 1e-6);
printf("%.7f\n", f);
printf("%.7f\n", f / 4);
printf("%.1f\n", f / 4);
return 0;
}

```

在笔者的机器上，输出如下：
0.9999990
0.2499998
0.2

换句话说，在不断减1e-6的过程中出现了误差，使得循环终止时f并不等于1，而是比1小一点。在除以4保留1位小数时成了0.2。如果不出现误差，正确答案应该是0.25四舍五入保留一位小数，即0.3。一道好的竞赛题目应避免这种情况出现，但作为竞赛选手来说，有一种方法可以缓解这种情况：加上一个EPS以后再输出。这里的EPS通常取一个比最低精度还要小几个数量级的小实数。例如，要求保留3位小数时取EPS为1e-6。这只是个权宜之计，甚至有可能起到“反作用”（如正确答案真的是0.499999），但在实践中很好用（毕竟正确答案是0.499999的情况比0.5要少很多）。