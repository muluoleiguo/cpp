## 6.1 再谈栈和队列

**例题6-1** 并行程序模拟（Concurrency Simulator, ACM/ICPC World Finals 1991,UVa210）



你的任务是模拟n个程序（按输入顺序编号为1～n）的并行执行。每个程序包含不超过25条语句，格式一共有5种：var = constant（赋值）；print var（打印）；lock；unlock；end。变量用单个小写字母表示，初始为0，为所有程序公有（因此在一个程序里对某个变量赋值可能会影响另一个程序）。常数是小于100的非负整数。每个时刻只能有一个程序处于运行态，其他程序均处于等待态。上述5种语句分别需要t1、t2、t3、t4、t5单位时间。运行态的程序每次最多运行Q个单位时间（称为配额）。当一个程序的配额用完之后，把当前语句（如果存在）执行完之后该程序会被插入一个等待队列中，然后处理器从队首取出一个程序继续执行。初始等待队列包含按输入顺序排列的各个程序，但由于lock/unlock语句的出现，这个顺序可能会改变。lock的作用是申请对所有变量的独占访问。lock和unlock总是成对出现，并且不会嵌套。lock总是在unlock的前面。当一个程序成功执行完lock指令之后，其他程序一旦试图执行lock指令，就会马上被放到一个所谓的阻止队列的尾部（没有用完的配额就浪费了）。当unlock执行完毕后，阻止队列的第一个程序进入等待队列的首部。输入n, t1, t2, t3, t4, t5, Q以及n个程序，按照时间顺序输出所有print语句的程序编号和结果。

```c++
Sample Input
3 1 1 1 1 1 1
a = 4
print a
lock
b = 9
print b
unlock
print b
end
a = 3
print a
lock
b = 8
print b
unlock
print b
end
b = 5
a = 17
print a
print b
lock
b = 21
print b
unlock
print b
end
Sample Output
1: 3
2: 3
3: 17
3: 9
1: 9
1: 9
2: 8
2: 8
3: 21
3: 21
```

【分析】
因为有“等待队列”和“阻止队列”的字眼，本题看上去是队列的一个简单应用，但请注意这句话：“阻止队列的第一个程序进入等待队列的首部”。这违反了队列的规则：新元素插入了队列首部而非尾部。有两个方法可以解决这个问题：

一是放弃STL队列，自己写一个支持“首部插入”的“队列”：用两个变量front和rear代表队列当前首尾下标，则传统的入队和出队分别是q[++rear] =x和x=q[front++]，而“插入到队首”则是q[--front] = x。细心的读者应该已经发现：如果front=0，则“插入到队首”会产生越界错误。确实如此，不过好在本题不会出现这样的情况






第二种方法是使用STL中的“双端队列”deque。它可以支持快速地在首尾两端进行插入和删除，