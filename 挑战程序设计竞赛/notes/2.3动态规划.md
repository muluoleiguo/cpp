## 2.3 记录结果再利用的“动态规划”

### 2.3.1 记忆化搜索与动态规划

01 背包问题

有n个重量和价值分别为 Wi,Vi,的物品。从这些物品中挑选出总重量不超过 W的物品，求所有挑选方案中价值总和的最大值。

要知道复习的必要性还是非常有用的！！

最朴素的方法，针对每个物品是否放入背包进行搜索试试看

```c++
// 输入
int n,W;
int w[MAX_N], v[MAX_N];
// 从第i个物品开始挑选总重小于j的部分
int rec(int i,int j){
	int res;
    if(i==n){
		//已经没有剩余物品了
        res=0;
    }else if(j<w[i]){
		//无法挑选这个物品
        res=rec(i+1,j);
    }else{
        //挑选和不挑选的两种情况都尝试一下
        res=max(rec(i+1,j),rec(i+1,j-w[i])+v[i]);
        
    }
    return res;
}
void solve(){
    printf("%d\n",rec(0,W));
}
```

只不过，这种方法的搜索深度是n，而且每一层的搜索都需要两次分支，最坏就需要0(2^n^)的时间，当n比较大时就没办法解了。所以要怎么办才好呢？为了优化之前的算法，我们看一下针对样例输人的情形下rec递归调用的情况。

![image-20210202164300824](C:\Users\55018\AppData\Roaming\Typora\typora-user-images\image-20210202164300824.png)

如图所示，rec以(3,2)为参数调用了两次。如果参数相同，返回的结果也应该相同，于是第二次调用时已经知道了结果却白白浪费了计算时间。让我们在这里把第一次计算时的结果记录下来，省略掉第二次以后的重复计算试试看。

```c++
int dp[MAX_N + 1][MAX_W + 1]; // 记忆化数组
int rec(int i,int j){
    if (dp[i][j] >= 0) {
	// 已经计算过的话直接使用之前的结果
        return dp[i][j];
    }
	...
    // 将结果记录在数组中
	return dp[i][j] =res;

}
void solve(){
	 memset(dp,-1,sizeof(dp));
    // 用-1表示尚未计算过，初始化整个数组
     printf("%d\n",rec(0,W));
}


```



专栏**使用memset进行初始化**
虽然 memset 按照 1 字节为单位对内存进行填充，-1 的每一位二进制位都是 1, 所以可以像0—样用 memset 进行初始化 通过使用 memset 可以快速地对高维数组等进行初始化，但是需要注意无法初始化成 1 之类的数值，



这微小的改进能降低多少复杂度呢？对于同样的参数，只会在第一次被调用到时执行递归部分，第二次之后都会直接返回。参数的组合不过 nW种,而函数内只调用2次递归，所以只需要的O(nW)复杂度就能解决这个问题。只需略微改良，可解的问题的规模就可以大幅提高。这种方法一般被称为记忆化搜索。



接下来，我们来仔细研究一下前面的算法利用到的这个记忆化数组。记`dp[i][j]`为根据rec的定义，从第i个物品开始挑选总重小于j时，总价值的最大值。于是我们有如下递推式

![image-20210202165047879](C:\Users\55018\AppData\Roaming\Typora\typora-user-images\image-20210202165047879.png)