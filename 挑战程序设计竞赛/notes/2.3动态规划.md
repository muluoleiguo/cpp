## 2.3 记录结果再利用的“动态规划”

### 2.3.1 记忆化搜索与动态规划

01 背包问题

有n个重量和价值分别为 Wi,Vi,的物品。从这些物品中挑选出总重量不超过 W的物品，求所有挑选方案中价值总和的最大值。

要知道复习的必要性还是非常有用的！！

最朴素的方法，针对每个物品是否放入背包进行搜索试试看

```c++
// 输入
int n,W;
int w[MAX_N], v[MAX_N];
// 从第i个物品开始挑选总重小于j的部分
int rec(int i,int j){
	int res;
    if(i==n){
		//已经没有剩余物品了
        res=0;
    }else if(j<w[i]){
		//无法挑选这个物品
        res=rec(i+1,j);
    }else{
        //挑选和不挑选的两种情况都尝试一下
        res=max(rec(i+1,j),rec(i+1,j-w[i])+v[i]);
        
    }
    return res;
}
void solve(){
    printf("%d\n",rec(0,W));
}
```

只不过，这种方法的搜索深度是n，而且每一层的搜索都需要两次分支，最坏就需要0(2^n^)的时间，当n比较大时就没办法解了。所以要怎么办才好呢？为了优化之前的算法，我们看一下针对样例输人的情形下rec递归调用的情况。

![image-20210202164300824](C:\Users\55018\AppData\Roaming\Typora\typora-user-images\image-20210202164300824.png)

如图所示，rec以(3,2)为参数调用了两次。如果参数相同，返回的结果也应该相同，于是第二次调用时已经知道了结果却白白浪费了计算时间。让我们在这里把第一次计算时的结果记录下来，省略掉第二次以后的重复计算试试看。

```c++
int dp[MAX_N + 1][MAX_W + 1]; // 记忆化数组
int rec(int i,int j){
    if (dp[i][j] >= 0) {
	// 已经计算过的话直接使用之前的结果
        return dp[i][j];
    }
	...
    // 将结果记录在数组中
	return dp[i][j] =res;

}
void solve(){
	 memset(dp,-1,sizeof(dp));
    // 用-1表示尚未计算过，初始化整个数组
     printf("%d\n",rec(0,W));
}


```



专栏**使用memset进行初始化**
虽然 memset 按照 1 字节为单位对内存进行填充，-1 的每一位二进制位都是 1, 所以可以像0—样用 memset 进行初始化 通过使用 memset 可以快速地对高维数组等进行初始化，但是需要注意无法初始化成 1 之类的数值，



这微小的改进能降低多少复杂度呢？对于同样的参数，只会在第一次被调用到时执行递归部分，第二次之后都会直接返回。参数的组合不过 nW种,而函数内只调用2次递归，所以只需要的O(nW)复杂度就能解决这个问题。只需略微改良，可解的问题的规模就可以大幅提高。这种方法一般被称为记忆化搜索。



接下来，我们来仔细研究一下前面的算法利用到的这个记忆化数组。记`dp[i][j]`为根据rec的定义，从第i个物品开始挑选总重小于j时，总价值的最大值。于是我们有如下递推式

![image-20210202165047879](C:\Users\55018\AppData\Roaming\Typora\typora-user-images\image-20210202165047879.png)

如上所示，不用写递归函数，直接利用递推式将各项的值计算出来，简单地用二重循环也苛以解决这一问题。

![image-20210202165503746](C:\Users\55018\AppData\Roaming\Typora\typora-user-images\image-20210202165503746.png)

```c++
int dp[MAX_N+1][MAX_W+1]; //dp数组
void solve(){
    for(int i=n-1;i>=0;i--){
		for(int j=0;j<=W;j++){
            if(j<w[i]){
                dp[i][j]=dp[i+1][j];
            }else {
                dp[i][j]=max(dp[i+1][j],dp[i+1][j-w[i]]+v[i]);
            }
        }
    }
    printf("%d\n",dp[0][W]);
}
```

这个算法的复杂度与前面相同，也是〇(nW) ,但是简洁了很多。以这种方式一步步按顺序求出问题的解的方法被称作动态规划法，也就是常说的DP.解决问题时既可以按照如上方法从记忆化搜索出发推导出递推式，熟练后也可以直接得出递推式。

**注意不要忘记初始化**
因为全局数组的内容会被初始化为 0, 所以前面的源代码中并没有显式地将初项=0 进行赋值，不过当一次运行要处理多组输入数据时，必须要进行初始化，这点一定要注意。



刚刚讲到 DP 中关于 i 的循环是逆向进行的。反之，如果按照如下的方式定义递推关系的话，关于 i的循环就能正向进行。

![image-20210202170428534](C:\Users\55018\AppData\Roaming\Typora\typora-user-images\image-20210202170428534.png)

```c++
void solve(){
    for(int i=0;i<n;i++){
		for(int j=0;j<=W;j++){
            if(j<w[i]){
                dp[i+1][j]=dp[i][j];
            }else {
                dp[i+1][j]=max(dp[i][j],dp[i][j-w[i]]+v[i]);
            }
        }
    }
    printf("%d\n",dp[0][W]);
}
```

此外，除了运用递推方式逐项求解之外，还可以把状态转移想象成从“前i个物品中选取总重不超过j时的状态”向“前i+1个物品中选取总重不超过j’和“前i+1个物品中选取总重不超过j+w[i]时的状态”的转移，于是可以实现成如下形式：

![image-20210202170610258](C:\Users\55018\AppData\Roaming\Typora\typora-user-images\image-20210202170610258.png)

```c++
void solve(){
    for(int i=0;i<n;i++){
		for(int j=0;j<=W;j++){
            dp[i+1][j]=max(dp[i+1][j],dp[i][j]);
            if(j+w[i]<=W){
                dp[i+1][j+w[i]]=max(dp[i+1][j+w[i]],dp[i][j]+v[i]);
            }       
        }
    }
    printf("%d\n",dp[n][W]);
}
```

如果像上述所示，把问题写成从当前状态迁移成下一状态的形式的话，需要注意初项之外也需要初始化（这个问题中，因为价值的总和至少是0, 所以初值设为0就可以了，不过根据问题也有可能需要初始化成无穷大 ）。 同一个问题可能会有各种各样的解决方法，诸如搜索的记忆化或者利用递推关系的DP, 再或者从状态转移考虑的DP等，不妨先把自己最喜欢的形式掌握熟练。但是，有些问题不用记忆化搜索也许很难求解，反之，不用DP复杂度就会变大的情况也会有，所以最好要掌握**各种形式的DP**.

有些被绕进去了。